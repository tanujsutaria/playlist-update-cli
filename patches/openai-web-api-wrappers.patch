diff --git a/README.md b/README.md
index d01eb62..c3bcc06 100644
--- a/README.md
+++ b/README.md
@@ -139,12 +139,19 @@ Bohemian Rhapsody,Queen
 The `/search` command uses Claude/Codex CLIs if available. It checks, in order:
 - `WEB_SEARCH_CLAUDE_CMD` / `WEB_SEARCH_CODEX_CMD`
 - `WEB_SCORE_CLAUDE_CMD` / `WEB_SCORE_CODEX_CMD`
-- `ANTHROPIC_API_KEY` / `OPENAI_API_KEY` (falls back to `claude` / `codex exec --search --output-schema ...`)
+- `ANTHROPIC_API_KEY` / `OPENAI_API_KEY` (uses `claude` and an OpenAI API wrapper)
 
 You can also set a generic command for search via `WEB_SEARCH_CMD`.
 If your CLI needs extra flags (or doesn't support `--json`), set the full command explicitly
-with `WEB_SEARCH_CLAUDE_CMD` / `WEB_SEARCH_CODEX_CMD`. If you see
-`stdin is not a terminal`, use `codex exec --search --output-schema ... -`.
+with `WEB_SEARCH_CLAUDE_CMD` / `WEB_SEARCH_CODEX_CMD`.
+
+OpenAI API wrapper (recommended for Codex search):
+```bash
+export WEB_SEARCH_CODEX_CMD="python -m src.openai_web_search_wrapper"
+export WEB_SEARCH_MODEL="gpt-4o"
+export WEB_SEARCH_TOOL_CHOICE="required"  # optional: auto|required|none
+export WEB_SEARCH_TOOL="web_search"        # optional: web_search|web_search_preview
+```
 
 ## Validation rules for /search
 - If your query includes a monthly listeners constraint (for example, "under 50k monthly listeners"),
@@ -168,6 +175,14 @@ Each command should read JSON from stdin and write JSON to stdout with a `scores
 (`artist|||song`) to a 0-1 relevance score.
 If your CLI supports JSON flags, add them here (for example, `claude --json`).
 
+OpenAI API wrapper (recommended for scoring):
+```bash
+export WEB_SCORE_CODEX_CMD="python -m src.openai_web_score_wrapper"
+export WEB_SCORE_MODEL="gpt-4o"
+export WEB_SCORE_TOOL_CHOICE="required"  # optional: auto|required|none
+export WEB_SCORE_TOOL="web_search"       # optional: web_search|web_search_preview
+```
+
 If no web command is configured, the app falls back to local scoring.
 
 ## Notes
diff --git a/pyproject.toml b/pyproject.toml
index da31f52..cb63cf2 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -16,6 +16,7 @@ dependencies = [
     "tqdm>=4.65.0",
     "rich>=13.7.0",
     "textual>=0.52.1",
+    "openai>=1.40.0",
     "scikit-learn>=1.3.0",
     "matplotlib>=3.7.1",
     "pytest>=7.3.1",
diff --git a/src/scoring.py b/src/scoring.py
index 14b8014..3f9a274 100644
--- a/src/scoring.py
+++ b/src/scoring.py
@@ -3,8 +3,11 @@ from __future__ import annotations
 import json
 import logging
 import os
+import re
 import shlex
 import subprocess
+import sys
+from pathlib import Path
 from dataclasses import dataclass
 from datetime import datetime
 from typing import Dict, Iterable, List, Optional, Sequence, Tuple
@@ -296,6 +299,11 @@ class WebSearchScoreProvider(ScoreProvider):
                     logger.info("Retrying %s with codex exec (non-interactive)", label)
                     return self._run_command(label, "codex exec -", payload)
                 if label == "codex" and self._stderr_unknown_argument(result.stderr):
+                    flag = self._stderr_unknown_argument_flag(result.stderr)
+                    if flag:
+                        logger.info("Retrying %s without unsupported flag %s", label, flag)
+                        stripped = self._strip_flag(args, flag, takes_value=(flag == "--output-schema"))
+                        return self._run_command(label, " ".join(stripped), payload)
                     logger.info("Retrying %s without unsupported codex flags", label)
                     stripped = self._strip_flag(args, "--search", takes_value=False)
                     return self._run_command(label, " ".join(stripped), payload)
@@ -343,6 +351,13 @@ class WebSearchScoreProvider(ScoreProvider):
         lowered = (stderr or "").lower()
         return "unexpected argument" in lowered
 
+    @staticmethod
+    def _stderr_unknown_argument_flag(stderr: str) -> Optional[str]:
+        match = re.search(r"unexpected argument '([^']+)'", stderr, flags=re.IGNORECASE)
+        if match:
+            return match.group(1)
+        return None
+
     @staticmethod
     def _strip_flag(args: List[str], flag: str, takes_value: bool) -> List[str]:
         if flag not in args:
@@ -387,6 +402,11 @@ class WebSearchScoreProvider(ScoreProvider):
         return {song_id: score / divisor for song_id, score in combined.items()}
 
 
+def _default_openai_web_score_command() -> str:
+    script_path = Path(__file__).resolve().with_name("openai_web_score_wrapper.py")
+    return shlex.join([sys.executable, str(script_path)])
+
+
 class ScorePipeline:
     def __init__(self, providers: Sequence[ScoreProvider], weights: Optional[Dict[str, float]] = None):
         self.providers = list(providers)
@@ -490,6 +510,8 @@ class MatchScorer:
         codex = os.getenv("WEB_SCORE_CODEX_CMD")
         if codex:
             commands["codex"] = codex
+        if not commands and os.getenv("OPENAI_API_KEY"):
+            commands["codex"] = _default_openai_web_score_command()
         return commands
 
     def _providers(self) -> Sequence[ScoreProvider]:
diff --git a/src/web_search.py b/src/web_search.py
index 3c67174..c9bd35c 100644
--- a/src/web_search.py
+++ b/src/web_search.py
@@ -6,6 +6,8 @@ import os
 import re
 import shlex
 import subprocess
+import sys
+from pathlib import Path
 from datetime import datetime
 from typing import Dict, Iterable, List, Optional, Tuple
 
@@ -56,7 +58,7 @@ def detect_search_commands(env: Optional[dict] = None) -> Dict[str, str]:
     if codex_cmd:
         commands["codex"] = codex_cmd
     elif env.get("OPENAI_API_KEY"):
-        commands["codex"] = _default_codex_command()
+        commands["codex"] = _default_openai_web_search_command()
 
     if not commands:
         generic_cmd = env.get("WEB_SEARCH_CMD") or env.get("WEB_SCORE_CMD")
@@ -263,6 +265,13 @@ def _run_command(label: str, command: str, payload: dict, timeout_sec: int) -> T
                 args, input_text = _prepare_codex_command(["codex", "exec", "-"], payload)
                 return _run_command(label, " ".join(args), payload, timeout_sec)
             if label == "codex" and _stderr_unknown_argument(result.stderr):
+                flag = _stderr_unknown_argument_flag(result.stderr)
+                if flag:
+                    logger.info("Retrying %s without unsupported flag %s", label, flag)
+                    args = _strip_flag(args, flag, takes_value=(flag == "--output-schema"))
+                    if flag == "--search":
+                        logger.warning("Codex CLI does not support --search; running without web search.")
+                    return _run_command(label, " ".join(args), payload, timeout_sec)
                 logger.info("Retrying %s without unsupported codex flags", label)
                 args = _strip_flag(args, "--search", takes_value=False)
                 args = _strip_flag(args, "--output-schema", takes_value=True)
@@ -292,6 +301,11 @@ def _default_codex_command() -> str:
     return f'codex exec --search --output-schema {schema} -'
 
 
+def _default_openai_web_search_command() -> str:
+    script_path = Path(__file__).resolve().with_name("openai_web_search_wrapper.py")
+    return shlex.join([sys.executable, str(script_path)])
+
+
 def _codex_schema() -> str:
     return (
         '{"type":"object","properties":{"summary":{"type":"string"},"results":{"type":"array","items":{"type":"object","properties":{"song":{"type":"string"},"artist":{"type":"string"},"year":{"type":["string","number"]},"why":{"type":"string"},"sources":{"type":"array","items":{"type":"string"}},"metrics":{"type":"object"},"score":{"type":["number","null"]}},"required":["song","artist","sources","metrics"]}}},"required":["summary","results"]}'
@@ -324,6 +338,13 @@ def _stderr_unknown_argument(stderr: str) -> bool:
     return "unexpected argument" in lowered
 
 
+def _stderr_unknown_argument_flag(stderr: str) -> Optional[str]:
+    match = re.search(r"unexpected argument '([^']+)'", stderr, flags=re.IGNORECASE)
+    if match:
+        return match.group(1)
+    return None
+
+
 def _parse_json_output(text: str) -> Optional[object]:
     if text:
         candidate = text.strip()
diff --git a/src/openai_web_search_wrapper.py b/src/openai_web_search_wrapper.py
new file mode 100644
index 0000000..b4c9bc0
--- /dev/null
+++ b/src/openai_web_search_wrapper.py
@@ -0,0 +1,188 @@
+from __future__ import annotations
+
+import json
+import os
+import re
+import sys
+from typing import Any, Dict, List, Optional
+
+from openai import OpenAI
+
+DEFAULT_INSTRUCTIONS = (
+    "You are a music research assistant. Use web search to find new songs that match the user's "
+    "criteria. Follow the provided source_policy (tiers, requirements) and any constraints "
+    "(e.g., max monthly listeners). Return JSON only with a top-level 'summary' and a 'results' "
+    "list. The summary should explain why these recommendations fit the user's criteria. Each "
+    "result must include: song, artist, year (if known), why (short rationale), sources (list of "
+    "URLs), and metrics (object) for any user-requested metrics. If the query implies similarity "
+    "(e.g., 'like X'), include a 'similarity' metric (0-1). If the query includes monthly listeners "
+    "constraints, include a 'monthly_listeners' metric and cite sources. Optionally include a "
+    "score 0-1 indicating fit confidence."
+)
+
+
+def main() -> int:
+    raw = sys.stdin.read()
+    if not raw.strip():
+        print("No input received on stdin.", file=sys.stderr)
+        return 1
+
+    try:
+        payload = json.loads(raw)
+    except json.JSONDecodeError as exc:
+        print(f"Invalid JSON input: {exc}", file=sys.stderr)
+        return 1
+
+    prompt = _build_prompt(payload)
+    model = os.getenv("WEB_SEARCH_MODEL", "gpt-4o")
+    tool_type = os.getenv("WEB_SEARCH_TOOL", "web_search")
+    tool_choice = os.getenv("WEB_SEARCH_TOOL_CHOICE", "").strip().lower()
+
+    client = OpenAI()
+    request: Dict[str, Any] = {
+        "model": model,
+        "input": prompt,
+        "tools": [{"type": tool_type}],
+    }
+    if tool_choice in {"auto", "required", "none"}:
+        request["tool_choice"] = tool_choice
+
+    try:
+        response = client.responses.create(**request)
+    except Exception as exc:
+        if _is_tool_type_error(exc, tool_type) and tool_type == "web_search":
+            request["tools"] = [{"type": "web_search_preview"}]
+            try:
+                response = client.responses.create(**request)
+            except Exception as retry_exc:
+                print(f"OpenAI API error: {retry_exc}", file=sys.stderr)
+                return 1
+        else:
+            print(f"OpenAI API error: {exc}", file=sys.stderr)
+            return 1
+
+    output_text = getattr(response, "output_text", None) or _extract_output_text(response)
+    parsed = _parse_json_output(output_text or "")
+    if parsed is None:
+        summary = (output_text or "").strip()
+        parsed = {"summary": summary[:2000], "results": []}
+    elif isinstance(parsed, list):
+        parsed = {"summary": "", "results": parsed}
+
+    json.dump(parsed, sys.stdout)
+    return 0
+
+
+def _build_prompt(payload: dict) -> str:
+    instructions = payload.get("instructions") or DEFAULT_INSTRUCTIONS
+    trimmed = {key: value for key, value in payload.items() if key != "instructions"}
+    return (
+        f"{instructions}\n\n"
+        "Input JSON:\n"
+        f"{json.dumps(trimmed, indent=2)}\n\n"
+        "Return JSON only."
+    )
+
+
+def _extract_output_text(response: Any) -> str:
+    output = getattr(response, "output", None)
+    if not isinstance(output, list):
+        return ""
+    texts: List[str] = []
+    for item in output:
+        content = getattr(item, "content", None) or item.get("content") if isinstance(item, dict) else None
+        if not isinstance(content, list):
+            continue
+        for chunk in content:
+            text = None
+            if isinstance(chunk, dict):
+                if chunk.get("type") == "output_text":
+                    text = chunk.get("text")
+                elif "text" in chunk:
+                    text = chunk.get("text")
+            else:
+                text = getattr(chunk, "text", None)
+            if text:
+                texts.append(str(text))
+    return "\n".join(texts)
+
+
+def _parse_json_output(text: str) -> Optional[object]:
+    if not text:
+        return None
+    candidate = _strip_fence(text)
+    if candidate:
+        parsed = _try_parse_json(candidate)
+        if parsed is not None:
+            return parsed
+
+    try:
+        return json.loads(text)
+    except json.JSONDecodeError:
+        pass
+
+    fenced = re.search(r"```json\\s*([\\s\\S]*?)```", text, flags=re.IGNORECASE)
+    if fenced:
+        parsed = _try_parse_json(fenced.group(1).strip())
+        if parsed is not None:
+            return parsed
+
+    fenced = re.search(r"```\\s*([\\s\\S]*?)```", text)
+    if fenced:
+        parsed = _try_parse_json(fenced.group(1).strip())
+        if parsed is not None:
+            return parsed
+
+    brace_match = _extract_json_block(text, "{", "}")
+    if brace_match:
+        parsed = _try_parse_json(brace_match)
+        if parsed is not None:
+            return parsed
+
+    bracket_match = _extract_json_block(text, "[", "]")
+    if bracket_match:
+        parsed = _try_parse_json(bracket_match)
+        if parsed is not None:
+            return parsed
+
+    return None
+
+
+def _strip_fence(text: str) -> Optional[str]:
+    candidate = text.strip()
+    if candidate.startswith("```json"):
+        candidate = candidate[len("```json") :]
+    if candidate.startswith("```"):
+        candidate = candidate[len("```") :]
+    if candidate.endswith("```"):
+        candidate = candidate[: -3]
+    candidate = candidate.strip()
+    if (candidate.startswith("{") and candidate.endswith("}")) or (
+        candidate.startswith("[") and candidate.endswith("]")
+    ):
+        return candidate
+    return None
+
+
+def _try_parse_json(candidate: str) -> Optional[object]:
+    try:
+        return json.loads(candidate)
+    except json.JSONDecodeError:
+        return None
+
+
+def _extract_json_block(text: str, open_char: str, close_char: str) -> Optional[str]:
+    start = text.find(open_char)
+    end = text.rfind(close_char)
+    if start == -1 or end == -1 or end <= start:
+        return None
+    return text[start : end + 1].strip()
+
+
+def _is_tool_type_error(exc: Exception, tool_type: str) -> bool:
+    message = str(exc).lower()
+    return "tool" in message and tool_type in message and ("invalid" in message or "unsupported" in message)
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/src/openai_web_score_wrapper.py b/src/openai_web_score_wrapper.py
new file mode 100644
index 0000000..d423091
--- /dev/null
+++ b/src/openai_web_score_wrapper.py
@@ -0,0 +1,168 @@
+from __future__ import annotations
+
+import json
+import os
+import re
+import sys
+from typing import Any, Dict, List, Optional
+
+from openai import OpenAI
+
+
+def main() -> int:
+    raw = sys.stdin.read()
+    if not raw.strip():
+        print("No input received on stdin.", file=sys.stderr)
+        return 1
+
+    try:
+        payload = json.loads(raw)
+    except json.JSONDecodeError as exc:
+        print(f"Invalid JSON input: {exc}", file=sys.stderr)
+        return 1
+
+    prompt = _build_prompt(payload)
+    model = os.getenv("WEB_SCORE_MODEL") or os.getenv("WEB_SEARCH_MODEL") or "gpt-4o"
+    tool_type = os.getenv("WEB_SCORE_TOOL", os.getenv("WEB_SEARCH_TOOL", "web_search"))
+    tool_choice = os.getenv("WEB_SCORE_TOOL_CHOICE", "").strip().lower()
+
+    client = OpenAI()
+    request: Dict[str, Any] = {
+        "model": model,
+        "input": prompt,
+        "tools": [{"type": tool_type}],
+    }
+    if tool_choice in {"auto", "required", "none"}:
+        request["tool_choice"] = tool_choice
+
+    try:
+        response = client.responses.create(**request)
+    except Exception as exc:
+        if _is_tool_type_error(exc, tool_type) and tool_type == "web_search":
+            request["tools"] = [{"type": "web_search_preview"}]
+            try:
+                response = client.responses.create(**request)
+            except Exception as retry_exc:
+                print(f"OpenAI API error: {retry_exc}", file=sys.stderr)
+                return 1
+        else:
+            print(f"OpenAI API error: {exc}", file=sys.stderr)
+            return 1
+
+    output_text = getattr(response, "output_text", None) or _extract_output_text(response)
+    parsed = _parse_json_output(output_text or "")
+    if parsed is None:
+        parsed = {"scores": {}}
+    if isinstance(parsed, list):
+        parsed = {"scores": {}}
+    if isinstance(parsed, dict) and "scores" not in parsed:
+        parsed = {"scores": {}}
+
+    json.dump(parsed, sys.stdout)
+    return 0
+
+
+def _build_prompt(payload: dict) -> str:
+    return (
+        "Use web search to judge how well each candidate fits the playlist theme. "
+        "Return JSON with a 'scores' object mapping song id to a 0-1 score.\n\n"
+        "Input JSON:\n"
+        f"{json.dumps(payload, indent=2)}\n\n"
+        "Return JSON only."
+    )
+
+
+def _extract_output_text(response: Any) -> str:
+    output = getattr(response, "output", None)
+    if not isinstance(output, list):
+        return ""
+    texts: List[str] = []
+    for item in output:
+        content = getattr(item, "content", None) or item.get("content") if isinstance(item, dict) else None
+        if not isinstance(content, list):
+            continue
+        for chunk in content:
+            text = None
+            if isinstance(chunk, dict):
+                if chunk.get("type") == "output_text":
+                    text = chunk.get("text")
+                elif "text" in chunk:
+                    text = chunk.get("text")
+            else:
+                text = getattr(chunk, "text", None)
+            if text:
+                texts.append(str(text))
+    return "\n".join(texts)
+
+
+def _parse_json_output(text: str) -> Optional[object]:
+    if not text:
+        return None
+    candidate = _strip_fence(text)
+    if candidate:
+        parsed = _try_parse_json(candidate)
+        if parsed is not None:
+            return parsed
+
+    try:
+        return json.loads(text)
+    except json.JSONDecodeError:
+        pass
+
+    fenced = re.search(r"```json\\s*([\\s\\S]*?)```", text, flags=re.IGNORECASE)
+    if fenced:
+        parsed = _try_parse_json(fenced.group(1).strip())
+        if parsed is not None:
+            return parsed
+
+    fenced = re.search(r"```\\s*([\\s\\S]*?)```", text)
+    if fenced:
+        parsed = _try_parse_json(fenced.group(1).strip())
+        if parsed is not None:
+            return parsed
+
+    brace_match = _extract_json_block(text, "{", "}")
+    if brace_match:
+        parsed = _try_parse_json(brace_match)
+        if parsed is not None:
+            return parsed
+
+    return None
+
+
+def _strip_fence(text: str) -> Optional[str]:
+    candidate = text.strip()
+    if candidate.startswith("```json"):
+        candidate = candidate[len("```json") :]
+    if candidate.startswith("```"):
+        candidate = candidate[len("```") :]
+    if candidate.endswith("```"):
+        candidate = candidate[: -3]
+    candidate = candidate.strip()
+    if candidate.startswith("{") and candidate.endswith("}"):
+        return candidate
+    return None
+
+
+def _try_parse_json(candidate: str) -> Optional[object]:
+    try:
+        return json.loads(candidate)
+    except json.JSONDecodeError:
+        return None
+
+
+def _extract_json_block(text: str, open_char: str, close_char: str) -> Optional[str]:
+    start = text.find(open_char)
+    end = text.rfind(close_char)
+    if start == -1 or end == -1 or end <= start:
+        return None
+    return text[start : end + 1].strip()
+
+
+def _is_tool_type_error(exc: Exception, tool_type: str) -> bool:
+    message = str(exc).lower()
+    return "tool" in message and tool_type in message and ("invalid" in message or "unsupported" in message)
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
